我们使用Anchor框架来编写这个众筹智能合约。根据需求，我们将实现以下功能：

创建众筹项目

更新项目信息（仅未开始状态且仅所有者）

开始众筹（仅未开始状态且仅所有者）

捐赠资金（仅进行中状态，自动处理超额捐赠，记录捐赠者）

完成众筹（手动触发，仅进行中状态且已到期，仅所有者）

分配资金（根据成功或失败，成功则转给所有者，失败则按比例退款）

添加进度更新（仅所有者）

关闭账户（在资金分配后，仅所有者）

注意：租金管理在创建账户时存入，关闭账户时退还。

我们将定义以下账户结构：

FundingAccount: 存储众筹项目的所有信息。

状态枚举：NotStarted, Ongoing, Completed, Failed, Closed。

我们使用BTreeMap来存储捐赠记录，以便在退款时按比例计算。

由于Anchor对账户大小有要求，我们需要预先分配足够的空间。考虑到字符串字段和动态数组（标签、更新、捐赠记录）的最大可能大小，我们为FundingAccount分配足够的空间。

另外，我们还需要一个账户来存储每次进度更新的信息，但为了简化，我们将进度更新直接存储在FundingAccount中。

考虑到存储成本，我们可能会限制一些数组的最大长度。

现在，我们开始编写代码。

注意：在Solana中，账户大小固定，因此我们需要为字符串和数组预留最大空间。

根据需求，我们设定：

项目名称: 128字符 -> 128字节

项目描述: 1024字符 -> 1024字节

项目分类: 64字符 -> 64字节

标签列表: 最多10个标签，每个最大32字符 -> 10 * 32 = 320字节

进度更新: 我们假设最多10次更新，每次更新内容最大1024字符，加上时间戳（i64，8字节） -> 10 * (1024 + 8) = 10320字节

捐赠记录: 我们使用BTreeMap，但考虑到账户大小，我们可能无法存储无限多的捐赠记录。因此，我们设定一个最大捐赠记录数，比如1000。每个捐赠记录是Pubkey（32字节）和u64（8字节），所以1000条记录需要1000 * (32+8) = 40000字节。

但是，账户大小可能超过10MB，这可能会很昂贵。因此，我们可能需要重新考虑存储捐赠记录的方式。另一种做法是不在账户中存储捐赠记录，而是使用PDA（Program Derived Address）为每个捐赠者存储一个捐赠账户，这样每个捐赠者都有一个账户，记录其捐赠金额。然后，在退款时，我们可以遍历所有捐赠账户来按比例退款。但是，这样会增加租金成本，并且遍历所有账户在Solana上可能受到交易大小限制。

考虑到这些，我们决定在FundingAccount中存储捐赠记录，但限制最大捐赠记录数为1000。如果捐赠者超过1000，则不再接受新的捐赠者（但允许已捐赠者再次捐赠）。或者，我们可以使用一个单独的账户来存储捐赠记录，但为了简化，我们暂时放在同一个账户中。

我们计算一下账户总大小：

基础字段：8（discriminator）+ 8（goal）+ 8（raised）+ 8（end_time）+ 1（status）+ 32（owner）+ 128（name）+ 1024（description）+ 64（category）+ 4（tags向量长度）+ 320（tags数据）+ 4（updates向量长度）+ 10320（updates数据）+ 4（donations BTreeMap长度）+ 40000（donations数据）≈ 52KB

这可能会超过Solana交易大小限制（约10KB）。因此，我们需要调整策略。

调整方案：

将捐赠记录单独存储在一个账户中，每个捐赠记录一个账户，这样我们可以通过PDA来查找每个捐赠者的捐赠金额。

或者，使用多个账户来存储捐赠记录，但这样会增加复杂性。

由于捐赠记录可能很多，我们采用PDA方式为每个捐赠者存储一个捐赠账户，这样每个捐赠者对应一个账户，记录其捐赠金额。同时，在FundingAccount中，我们只记录总捐赠金额和捐赠者数量。在退款时，我们按比例计算每个捐赠者的退款金额，然后逐个退款（或者让捐赠者自己申请退款）。

但是，按比例退款需要知道总捐赠金额和每个捐赠者的捐赠金额，我们可以通过遍历所有捐赠账户来计算总捐赠金额，但这样在智能合约中可能无法实现（因为交易大小限制和计算限制）。因此，我们改变退款方式：在众筹失败时，我们允许捐赠者自己提取他们的捐赠（全额提取）。这样，我们就不需要主动退款，而是由捐赠者主动提取。

但是，这样可能会导致一些捐赠者不提取，资金被锁定。因此，我们仍然需要主动退款。另一种做法是：在众筹失败时，项目所有者调用一个指令，逐个退款给捐赠者。但是，如果捐赠者很多，一个交易可能无法完成所有退款，需要多个交易。

考虑到这些，我们决定：

在FundingAccount中存储总捐赠金额，但不存储每个捐赠者的捐赠金额。每个捐赠者的捐赠金额存储在一个单独的账户中，即DonationAccount。当捐赠者捐赠时，我们同时创建或更新DonationAccount。在退款时，我们通过指令让捐赠者自己提取，或者由项目所有者分批退款。

但是，如果由捐赠者自己提取，那么我们需要提供一个新的指令，让捐赠者在众筹失败后提取他们的捐赠。同时，我们需要确保在众筹成功的情况下，捐赠者不能提取。

我们重新设计：

创建项目时，同时初始化FundingAccount。

捐赠时，用户调用donate指令，该指令会：

检查项目状态是否为Ongoing。

检查是否超过目标金额，如果超过则只接受部分捐赠并退还多余部分。

更新FundingAccount中的已筹金额。

创建或更新一个DonationAccount，记录该捐赠者在此项目中的捐赠总额。

众筹成功时，项目所有者可以提取资金（扣除租金后）。

众筹失败时，捐赠者可以提取他们的捐赠（扣除租金后）。或者由项目所有者主动退款，但考虑到Gas成本和交易大小，我们让捐赠者自己提取。

这样，我们不需要在退款时遍历所有捐赠者，而是由捐赠者主动提取。同时，我们记录每个捐赠者的捐赠金额，以便他们提取。

因此，我们需要两个账户结构：

FundingAccount: 存储项目信息，不包括捐赠记录，但包括总捐赠金额。

DonationAccount: 存储一个捐赠者对某个项目的捐赠金额。

状态转换：

未开始 -> 进行中：start_funding

进行中 -> 已完成：complete_funding（手动，仅所有者，且已到期）-> 如果达到目标则标记为Completed，否则标记为Failed。

进行中 -> 已失败：同上，在complete_funding中根据是否达到目标设置状态。

然后，我们提供两个新的指令：

withdraw_donation: 捐赠者在众筹失败后提取他们的捐赠。

withdraw_funds: 项目所有者在众筹成功后提取资金。

注意：在众筹成功的情况下，项目所有者提取资金时，我们直接将资金（扣除租金后）转给项目所有者，并关闭FundingAccount和所有DonationAccount？不，我们不会立即关闭DonationAccount，因为捐赠者可能已经提取了他们的捐赠（在失败的情况下）。在成功的情况下，捐赠者不能提取，所以DonationAccount可以保留，但为了节省租金，我们可以让项目所有者关闭DonationAccount吗？但是，项目所有者关闭DonationAccount需要支付租金，但捐赠者可能已经不在线了。所以，我们不考虑关闭DonationAccount，因为租金由捐赠者支付（创建DonationAccount时由捐赠者支付租金？）。

实际上，DonationAccount是由捐赠者支付的，因为创建账户需要支付租金。但是，在捐赠时，捐赠者已经支付了租金。在众筹失败后，捐赠者提取捐赠时，我们会将租金退还吗？是的，当我们关闭DonationAccount时，租金会退还给捐赠者。

因此，在捐赠者提取捐赠时，我们关闭DonationAccount，并将账户中的lamports（包括捐赠金额和租金）转给捐赠者。但是，注意，捐赠金额是捐赠者之前捐赠的，租金是捐赠者创建账户时支付的，所以一起退还。

同样，在项目所有者提取资金时，我们关闭FundingAccount，并将租金退还给项目所有者。

但是，在众筹成功的情况下，项目所有者提取资金时，我们只将筹集到的资金转给项目所有者，而租金仍然保留在FundingAccount中吗？不，我们可以在项目所有者提取资金时，同时关闭FundingAccount，并将租金退还给项目所有者。但是，这样就需要项目所有者主动关闭账户。我们也可以提供一个单独的关闭账户指令。

我们调整资金分配逻辑：

众筹成功：

项目所有者调用withdraw_funds，将筹集到的资金（扣除租金后）转给项目所有者，然后关闭FundingAccount。同时，我们还需要关闭所有的DonationAccount吗？不，我们不需要，因为捐赠者不能提取，而且DonationAccount的租金是由捐赠者支付的，我们无法强制关闭。但是，我们可以让项目所有者关闭DonationAccount并收取租金吗？不行，因为租金属于捐赠者。所以，在成功的情况下，DonationAccount由捐赠者支付租金，我们不去动它。捐赠者可以自己关闭DonationAccount并取回租金吗？不行，因为只有项目所有者可以关闭DonationAccount？不，DonationAccount的owner是程序，所以只有程序可以关闭。我们可以提供一个指令让捐赠者关闭DonationAccount并取回租金，但前提是众筹成功且他们已经不能提取捐赠了。但是，在成功的情况下，捐赠者没有理由关闭DonationAccount，因为他们已经捐赠了，资金已经转移给项目所有者。所以，在成功的情况下，DonationAccount将永远存在，直到捐赠者关闭它（但捐赠者可能不会主动关闭，因为租金很少）。这是一个问题。

另一种方案：在捐赠时，我们不创建单独的DonationAccount，而是使用一个账户存储所有捐赠记录，但这样又回到之前账户过大的问题。

或者，我们使用PDA来生成DonationAccount，这样捐赠者不需要支付租金，因为PDA不需要租金？不对，PDA也需要租金，但是我们可以通过 FundingAccount 来支付租金？不，租金必须由某个账户支付。

考虑到这些，我们决定：

在捐赠时，由捐赠者支付租金来创建DonationAccount。在众筹失败后，捐赠者提取捐赠时，我们关闭DonationAccount，将捐赠金额和租金退还。在众筹成功的情况下，捐赠者不能提取，但捐赠者可以关闭DonationAccount并取回租金吗？可以，我们提供一个指令，让捐赠者在众筹成功后关闭DonationAccount并取回租金。但是，这样捐赠者会损失捐赠金额，但取回租金。捐赠金额已经转移给项目所有者，所以捐赠者不能取回捐赠金额，只能取回租金。

因此，我们设计两个提取指令：

对于捐赠者：

在众筹失败的情况下，可以提取捐赠金额和租金。

在众筹成功的情况下，只能提取租金（即关闭DonationAccount，但捐赠金额已经不在）。

对于项目所有者：

在众筹成功的情况下，可以提取筹集到的资金（扣除FundingAccount的租金）并关闭FundingAccount。

在众筹失败的情况下，不能提取资金，但可以关闭FundingAccount并取回租金。

但是，在众筹失败的情况下，项目所有者关闭FundingAccount时，必须确保所有捐赠者已经提取了他们的捐赠。否则，项目所有者关闭FundingAccount后，捐赠者就无法提取了。因此，我们需要在FundingAccount中记录众筹失败，并允许捐赠者提取，直到所有捐赠者都提取完毕，项目所有者才能关闭FundingAccount。

这增加了复杂性。我们可以在众筹失败时，让项目所有者调用一个指令，将资金按比例退还给捐赠者，但这样又回到之前的问题。或者，我们不让项目所有者关闭FundingAccount，而是让捐赠者提取完毕后，自动关闭FundingAccount。

考虑到这些，我们决定：

在众筹失败时，我们不允许项目所有者立即关闭FundingAccount。我们让捐赠者自己提取他们的捐赠。当最后一个捐赠者提取后，FundingAccount的已筹金额变为0，然后项目所有者可以关闭FundingAccount。

我们可以在FundingAccount中记录捐赠者数量，但这样又需要存储捐赠者数量，而且捐赠者数量可能很大。我们也可以不记录，而是通过遍历所有DonationAccount来判断是否还有未提取的捐赠。但是，我们无法在智能合约中遍历账户。

因此，我们改变策略：在众筹失败时，我们不允许项目所有者提取资金，也不允许关闭FundingAccount，直到所有捐赠者都提取了他们的捐赠。但是，我们如何知道所有捐赠者都已经提取了呢？我们可以在FundingAccount中记录总捐赠金额，然后当捐赠者提取时，我们从总捐赠金额中减去提取的金额，当总捐赠金额变为0时，表示所有捐赠者都已经提取。

但是，这样有一个问题：如果某个捐赠者不提取，那么总捐赠金额永远不会为0，项目所有者就无法关闭FundingAccount，租金也无法退还。

因此，我们折中：在众筹失败后，我们允许项目所有者在一段时间后（比如30天）强制关闭FundingAccount，并将剩余资金转给项目所有者。这样，捐赠者有时间提取，但如果他们不提取，资金将归项目所有者。这并不合理，因为捐赠者的资金应该退还。

另一种折中：在众筹失败后，我们允许项目所有者主动按比例退款，但这样需要多个交易。我们提供一个指令，让项目所有者每次退款给一个捐赠者，直到退款完毕。然后，项目所有者可以关闭FundingAccount。

但是，这样项目所有者需要支付Gas费，而且如果捐赠者很多，可能需要很多交易。

考虑到用户体验，我们决定采用捐赠者主动提取的方式。同时，我们设置一个期限，在众筹失败后，项目所有者可以在一定时间后关闭FundingAccount，并将剩余资金转给项目所有者。这样，捐赠者需要在这个期限内提取，否则资金将归项目所有者。虽然这不完美，但可以接受。

我们将在FundingAccount中存储一个“可关闭时间”，即在众筹失败后，项目所有者可以关闭账户的时间。这个时间设置为众筹失败后30天。

现在，我们重新定义账户结构：

FundingAccount:

name: String (128)

description: String (1024)

category: String (64)

tags: Vec<String> (10个标签，每个32字符)

goal: u64

raised: u64

end_time: i64

status: FundingStatus

owner: Pubkey

updates: Vec<FundingUpdate> (最多10次更新，每次更新1024字符+时间戳)

total_donations: u64 // 总捐赠金额，在捐赠时增加，在捐赠者提取时减少

closable_at: Option<i64> // 在众筹失败后，设置一个可关闭的时间戳

DonationAccount:

funding: Pubkey // 对应的众筹项目

donor: Pubkey // 捐赠者

amount: u64 // 捐赠金额

withdrawn: bool // 是否已提取

状态转换：

未开始 -> 进行中: start_funding

进行中 -> 已完成: complete_funding (手动，仅所有者，且已到期) -> 如果raised >= goal，则状态为Completed，否则为Failed。
如果状态变为Failed，则设置closable_at为当前时间+30天。

指令列表：

create_funding: 创建众筹项目

update_funding: 更新项目信息（仅未开始状态）

start_funding: 开始众筹

donate: 捐赠

add_update: 添加进度更新

complete_funding: 完成众筹（手动，仅所有者，且已到期）

withdraw_donation: 捐赠者提取捐赠（仅Failed状态，或者成功状态下提取租金）

withdraw_funds: 项目所有者提取资金（仅Completed状态）

close_funding: 项目所有者关闭众筹账户（仅Failed状态，且当前时间>=closable_at，并且total_donations为0；或者Completed状态且资金已提取）

注意：在Completed状态下，项目所有者调用withdraw_funds时，我们将筹集到的资金转给项目所有者，并将FundingAccount中的raised设置为0，然后项目所有者可以调用close_funding关闭账户。

在Failed状态下，捐赠者调用withdraw_donation时，我们将捐赠金额转给捐赠者，并标记DonationAccount为withdrawn，同时从FundingAccount的total_donations中减去提取的金额。

在Failed状态下，当total_donations为0时，项目所有者可以随时关闭FundingAccount，而不需要等待closable_at。如果total_donations不为0，则必须等到closable_at之后，并且只能提取剩余的资金（即那些未提取的捐赠）并关闭账户。

但是，在Failed状态下，项目所有者关闭FundingAccount时，我们会将剩余的资金（即未提取的捐赠）转给项目所有者。这样，捐赠者如果不及时提取，就会损失资金。所以，我们需要在前端提醒捐赠者。
